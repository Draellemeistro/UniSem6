
> [!NOTE] Provoke some thought
> - Why is failure detection critical in distributed systems?
> - How do [[Byzantine failures]] differ from crash failures in terms of complexity?

> [!warning] By using **2k + 1** servers, we can establish [[k-fault tolerance]]. However, we need a total of **3k + 1** servers if it is needed to deal with arbitrary failures.

- [[Failure Terminology]] 
	- [[Dependability]]
	- Failure types: **crash**, **omission**, **timing**, **response**, [[arbitrary failure|arbitrary]] / [[Byzantine failures]] 
	- [[Halting Failures]]
- [[Failure Masking]]
	- [[Redundancy]]
		- [[Information-redundancy]]
		- [[Time-redundancy]]
		- [[Physical-redundancy]]
	- [[Process-groups]] and [[Process-resilience]]
- [[Consensus]]
	- [[arbitrary failure]]
		- [[Flood-based consensus algorithm]]
	- [[Byzantine failures]]
- [[CAP Theorem]]
- [[Failure-Detection]]
	- two-phase commit protocol
# Quick stuff
- Partial Failures
- Resilience by Process Groups
- Failure Detection
- [[Consensus]]
    - Crash Failures
    - [[Byzantine failures]]
- Distributed Commit Protocols
## Questions and Thoughts
- Why is failure detection critical in distributed systems?
- How do [[Byzantine failures]] differ from crash failures in terms of complexity?
## Relevant Terms from Other Lectures
- [[Leader Election]] (L8)
- [[Replication]] (L9)




# asdasd