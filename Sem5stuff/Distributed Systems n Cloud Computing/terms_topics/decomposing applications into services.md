- Organize teams around business capabilities, not tech layer
	- Cross functional teams by business are requisite
	- traditional tech. layer teams are expensive
(Extensive cross-team collabs & costly delays)

### When adopting a microservice architecture :
- **Design for failure** - applications must be designed and developed to tolerate the failures of other services or applications 
- **Single lifecycle ownership of the product** - “You build it, you run it” is the motto rather than the traditional practice of software development team handing off a service to an IT operations team. 
- **Exercise choice in platforms, language & libraries** that best suits the microservice functionality and team expertise rather than a single language or platform for the enterprise. 
- **Decentralized business and messaging rules** - complex centralized message handling such as enterprise service bus must give way to simple communications protocols. This is the referred to as “smart endpoints, dumb pipes” 
- **Decentralized governance** - minimize top-down standards or technology sets and allow in-house open-source model for sharing useful tested code
- **Decentralized data management** - to service-level data management, often called polyglot persistence.

# [[Monolithic Architecture]] to [[Microservice-based Architecture]]
## Core tenets and ideas
### Design for failure
### Single life-cycle ownership of the product
### Exercise choice in platforms, language and libraries
### Decentralized business & messaging rules
### Decentralized data management
### organize teams around business capabilities not tech-layer
### move beyond **continuous integration** to **continuous delivery**

## Example of basic automated build pipeline that supports continuous integration
